---
import { Image } from "astro:assets";

// Import all images from the ImageGallery folder
const images = import.meta.glob("../images/ImageGallery/*.{jpg,jpeg,png,gif,webp}", { eager: true });

const imageList = Object.entries(images).map(([path, module]: [string, any]) => ({
  src: module.default,
  alt: path.split("/").pop()?.replace(/\.(jpg|jpeg|png|gif|webp)$/i, "") || "Gallery Image",
}));
---

<div class="gallery-wrapper">
  <div class="gallery-inner">
    <h2 class="gallery-title">Pre-Wedding Gallery</h2>
    <div class="gallery-container" id="galleryContainer">
      <div class="gallery-scroll" id="galleryScroll">
        {/* Double the images for infinite scroll effect */}
        {[...imageList, ...imageList].map((image, index) => (
          <div class="gallery-item" data-index={index % imageList.length} data-real-index={index}>
            <Image
              src={image.src}
              alt={image.alt}
              class="gallery-image"
              width={640}
              height={960}
              loading="lazy"
              decoding="async"
            />
          </div>
        ))}
      </div>
    </div>
  </div>
</div>

<!-- Fullscreen Lightbox - Outside the constrained container -->
<div class="lightbox" id="lightbox">
  <button class="lightbox-close" id="lightboxClose" aria-label="Close gallery">
    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </button>
  
  <button class="lightbox-nav lightbox-prev" id="lightboxPrev" aria-label="Previous image">
    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15,18 9,12 15,6"></polyline>
    </svg>
  </button>
  
  <button class="lightbox-nav lightbox-next" id="lightboxNext" aria-label="Next image">
    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="9,18 15,12 9,6"></polyline>
    </svg>
  </button>
  
  <div class="lightbox-content" id="lightboxContent">
    <img class="lightbox-image" id="lightboxImage" src="" alt="" />
    <p class="lightbox-counter" id="lightboxCounter"></p>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const galleryItems = document.querySelectorAll('.gallery-item');
    const galleryContainer = document.querySelector('.gallery-container') as HTMLElement;
    const lightbox = document.getElementById('lightbox');
    const lightboxImage = document.getElementById('lightboxImage') as HTMLImageElement;
    const lightboxClose = document.getElementById('lightboxClose');
    const lightboxPrev = document.getElementById('lightboxPrev');
    const lightboxNext = document.getElementById('lightboxNext');
    const lightboxCounter = document.getElementById('lightboxCounter');
    const lightboxContent = document.getElementById('lightboxContent');
    
    let currentIndex = 0;
    const totalImages = galleryItems.length / 2; // Divide by 2 because we doubled the images
    
    // Calculate item width dynamically based on current layout
    function getItemWidth() {
      if (galleryItems.length === 0) return 300;
      const firstItem = galleryItems[0] as HTMLElement;
      const gap = 16; // approximate gap
      return firstItem.offsetWidth + gap;
    }
    
    // Store unique image sources (only from the first set)
    const imageSources: string[] = [];
    const uniqueItems = Array.from(galleryItems).slice(0, totalImages);
    uniqueItems.forEach((item) => {
      const img = item.querySelector('img');
      if (img) {
        imageSources.push(img.src);
      }
    });
    
    // ========== INFINITE SCROLL SETUP ==========
    let isHandlingScroll = false;
    let scrollCheckInterval: number | null = null;
    let lastJumpTime = 0;
    let oneSetWidth = 0;
    
    function calculateOneSetWidth() {
      if (!galleryContainer || totalImages === 0) return 0;
      const scrollWidth = galleryContainer.scrollWidth;
      oneSetWidth = scrollWidth / 2; // We have 2 sets
      return oneSetWidth;
    }
    
    function handleInfiniteScroll() {
      if (!galleryContainer || isHandlingScroll) return;

      if (oneSetWidth === 0) {
        calculateOneSetWidth();
      }
      
      const scrollLeft = galleryContainer.scrollLeft;

      // Only jump if enough time has passed since last jump
      const now = Date.now();
      if (now - lastJumpTime < 500) return;

      // If scrolled past the end of set 2, jump back to set 1
      if (scrollLeft >= oneSetWidth * 1.5) {
        isHandlingScroll = true;
        lastJumpTime = now;
        galleryContainer.scrollLeft = scrollLeft - oneSetWidth;
        setTimeout(() => { isHandlingScroll = false; }, 300);
      }
      // If scrolled near the start of set 1, jump forward to set 2
      else if (scrollLeft <= 20) {
        isHandlingScroll = true;
        lastJumpTime = now;
        galleryContainer.scrollLeft = scrollLeft + oneSetWidth;
        setTimeout(() => { isHandlingScroll = false; }, 300);
      }
    }
    
    // Set initial scroll position (after layout is ready)
    setTimeout(() => {
      if (galleryContainer) {
        calculateOneSetWidth();
        // Start at the beginning of set 2, slightly offset
        const initialPosition = oneSetWidth + 50;
        galleryContainer.scrollLeft = initialPosition;
      }
    }, 100);
    
    // Start interval to check scroll position frequently during scrolling
    function startScrollCheck() {
      if (scrollCheckInterval) return;
      scrollCheckInterval = window.setInterval(() => {
        handleInfiniteScroll();
      }, 100); // Check every 100ms during all scrolling
    }
    
    startScrollCheck();
    
    // ========== AUTO SCROLL (using requestAnimationFrame) ==========
    let autoScrollRAF: number | null = null;
    let userInteracting = false;
    let autoScrollResumeTimeout: number | null = null;
    const autoScrollSpeed = 1; // pixels per frame
    const autoScrollDelay = 3000; // 3 seconds delay before auto scroll resumes

    function autoScrollLoop() {
      if (!galleryContainer || userInteracting) {
        autoScrollRAF = requestAnimationFrame(autoScrollLoop);
        return;
      }
      galleryContainer.scrollLeft += autoScrollSpeed;
      autoScrollRAF = requestAnimationFrame(autoScrollLoop);
    }

    function startAutoScroll() {
      if (autoScrollRAF) return;
      autoScrollRAF = requestAnimationFrame(autoScrollLoop);
    }

    function stopAutoScroll() {
      if (autoScrollRAF) {
        cancelAnimationFrame(autoScrollRAF);
        autoScrollRAF = null;
      }
    }

    function pauseAutoScroll() {
      userInteracting = true;

      if (autoScrollResumeTimeout) {
        clearTimeout(autoScrollResumeTimeout);
      }

      autoScrollResumeTimeout = window.setTimeout(() => {
        userInteracting = false;
      }, autoScrollDelay);
    }

    // Start auto scroll after page load
    setTimeout(startAutoScroll, 1000);
    
    // ========== WHEEL SCROLL (Vertical to Horizontal) ==========
    if (galleryContainer) {
      galleryContainer.addEventListener('wheel', (e: WheelEvent) => {
        pauseAutoScroll();
        e.preventDefault();
        galleryContainer.scrollLeft += e.deltaY;
      }, { passive: false });
    }
    
    // ========== DRAG TO SCROLL ==========
    let isDown = false;
    let startX: number;
    let scrollLeft: number;
    
    if (galleryContainer) {
      galleryContainer.addEventListener('mousedown', (e: MouseEvent) => {
        pauseAutoScroll();
        isDown = true;
        galleryContainer.classList.add('active-drag');
        startX = e.pageX - galleryContainer.offsetLeft;
        scrollLeft = galleryContainer.scrollLeft;
      });
      
      galleryContainer.addEventListener('mouseleave', () => {
        isDown = false;
        galleryContainer.classList.remove('active-drag');
      });
      
      galleryContainer.addEventListener('mouseup', () => {
        isDown = false;
        galleryContainer.classList.remove('active-drag');
      });
      
      galleryContainer.addEventListener('mousemove', (e: MouseEvent) => {
        if (!isDown) return;
        e.preventDefault();
        const x = e.pageX - galleryContainer.offsetLeft;
        const walk = (x - startX) * 2; // Scroll-fast multiplier
        galleryContainer.scrollLeft = scrollLeft - walk;
      });
    }
    
    // ========== TOUCH SUPPORT (Mobile) ==========
    // Remove custom touch handler - let native scroll handle it for smooth momentum
    // But add listeners to pause auto-scroll on touch
    if (galleryContainer) {
      galleryContainer.addEventListener('touchstart', () => {
        pauseAutoScroll();
      }, { passive: true });
    }
    
    // Store original parent to restore later
    let lightboxOriginalParent: HTMLElement | null = null;
    
    function openLightbox(index: number) {
      currentIndex = index;
      updateLightboxImage();
      
      // Move lightbox to body to escape parent container constraints
      if (lightbox && !lightboxOriginalParent) {
        lightboxOriginalParent = lightbox.parentElement as HTMLElement;
        document.body.appendChild(lightbox);
      }
      
      lightbox?.classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    
    function closeLightbox() {
      lightbox?.classList.remove('active');
      document.body.style.overflow = '';
      
      // Move lightbox back to original parent after transition
      setTimeout(() => {
        if (lightbox && lightboxOriginalParent) {
          lightboxOriginalParent.appendChild(lightbox);
          lightboxOriginalParent = null;
        }
      }, 300);
    }
    
    function updateLightboxImage() {
      if (lightboxImage && imageSources[currentIndex]) {
        lightboxImage.src = imageSources[currentIndex];
        const galleryItem = galleryItems[currentIndex];
        const img = galleryItem?.querySelector('img');
        if (img && lightboxImage) {
          lightboxImage.alt = img.alt;
        }
      }
      if (lightboxCounter) {
        lightboxCounter.textContent = `${currentIndex + 1} / ${totalImages}`;
      }
    }
    
    function showPrev() {
      currentIndex = (currentIndex - 1 + totalImages) % totalImages;
      updateLightboxImage();
    }

    function showNext() {
      currentIndex = (currentIndex + 1) % totalImages;
      updateLightboxImage();
    }
    
    // Event listeners - use data-index for the actual image index
    galleryItems.forEach((item) => {
      item.addEventListener('click', () => {
        const index = parseInt(item.getAttribute('data-index') || '0');
        openLightbox(index);
      });
    });
    
    lightboxClose?.addEventListener('click', closeLightbox);
    lightboxPrev?.addEventListener('click', showPrev);
    lightboxNext?.addEventListener('click', showNext);
    
    // Close on background click (clicking outside the image)
    lightbox?.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      // Close if clicking on lightbox background or lightbox-content (not on image or counter)
      if (target === lightbox || target === lightboxContent) {
        closeLightbox();
      }
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (!lightbox?.classList.contains('active')) return;
      
      switch (e.key) {
        case 'Escape':
          closeLightbox();
          break;
        case 'ArrowLeft':
          showPrev();
          break;
        case 'ArrowRight':
          showNext();
          break;
      }
    });
    
    // ========== LIGHTBOX SWIPE NAVIGATION ==========
    let lightboxTouchStartX = 0;
    let lightboxTouchStartY = 0;
    let lightboxTouchEndX = 0;
    let lightboxTouchEndY = 0;
    const minSwipeDistance = 50; // Minimum distance for a swipe
    
    if (lightbox) {
      lightbox.addEventListener('touchstart', (e: TouchEvent) => {
        lightboxTouchStartX = e.changedTouches[0].screenX;
        lightboxTouchStartY = e.changedTouches[0].screenY;
      }, { passive: true });
      
      lightbox.addEventListener('touchend', (e: TouchEvent) => {
        lightboxTouchEndX = e.changedTouches[0].screenX;
        lightboxTouchEndY = e.changedTouches[0].screenY;
        handleLightboxSwipe();
      }, { passive: true });
    }
    
    function handleLightboxSwipe() {
      const deltaX = lightboxTouchEndX - lightboxTouchStartX;
      const deltaY = lightboxTouchEndY - lightboxTouchStartY;
      const absDeltaX = Math.abs(deltaX);
      const absDeltaY = Math.abs(deltaY);
      
      // Only handle horizontal swipes (ignore vertical swipes)
      if (absDeltaX > absDeltaY && absDeltaX > minSwipeDistance) {
        if (deltaX > 0) {
          // Swiped right -> show previous
          showPrev();
        } else {
          // Swiped left -> show next
          showNext();
        }
      }
    }
  });
</script>

<style>
  .gallery-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    background-color: #517470;

  /* Width constrained to 9:18 ratio relative to viewport height */
  .gallery-inner {
    width: min(100vw, 50vh); /* 50vh = 9/18 of 100vh */
    max-width: 100%;
    display: flex;
    background-color: #efefef;
    flex-direction: column;
    justify-content: center;
    container-type: inline-size;
    padding-top: calc(var(--calculated-width) * 0.05);
    padding-bottom: calc(var(--calculated-width) * 0.05);
  }
  }

  .gallery-title {
    text-align: center;
    color: #232323;
    margin: 2cqi 0;
    font-family: 'palmaton', serif;
    font-size: 9cqi;
    font-weight: 400;
    flex-shrink: 0;
  }

  .gallery-container {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    cursor: grab;
    user-select: none;
    -webkit-user-select: none;
    /* Hide scrollbar for all browsers */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE 10+ */
  }
  
  /* Hide scrollbar for Chrome, Safari, and Opera */
  .gallery-container::-webkit-scrollbar {
    display: none;
  }
  
  .gallery-container.active-drag {
    cursor: grabbing;
  }
  
  .gallery-container:active {
    cursor: grabbing;
  }
  
  .gallery-scroll {
    display: flex;
    gap: 2cqi;
    padding: 0 2cqi;
    width: max-content;
    align-items: center;
    padding-top: 5%;
    padding-bottom: 5%;
  }
  
  .gallery-item {
    flex-shrink: 0;
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    border-radius: 1cqi;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  
  .gallery-item img {
    pointer-events: none;
    -webkit-user-drag: none;
    user-select: none;
  }
  
  .gallery-item:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  }
  
  .gallery-image {
    width: 22cqi;
    height: 33cqi;
    object-fit: cover;
    display: block;
  }
  
  /* Lightbox Styles */
  .lightbox {
    position: fixed;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background-color: rgba(0, 0, 0, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }
  
  .lightbox.active {
    opacity: 1;
    visibility: visible;
  }
  
  .lightbox-content {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .lightbox-image {
    max-width: 100vw;
    max-height: 100vh;
    width: auto;
    height: auto;
    object-fit: contain;
  }
  
  .lightbox-counter {
    color: #fff;
    margin-top: 1rem;
    font-size: 1rem;
    opacity: 0.8;
  }
  
  .lightbox-close,
  .lightbox-nav {
    position: absolute;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: #fff;
    cursor: pointer;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s ease, transform 0.2s ease;
    z-index: 1001;
  }
  
  .lightbox-close:hover,
  .lightbox-nav:hover {
    background-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
  }
  
  .lightbox-close {
    top: 20px;
    right: 20px;
  }
  
  .lightbox-prev {
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  .lightbox-prev:hover {
    transform: translateY(-50%) scale(1.1);
  }
  
  .lightbox-next {
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  .lightbox-next:hover {
    transform: translateY(-50%) scale(1.1);
  }
  
  @media (max-aspect-ratio: 0.5) {
    .gallery-image {
      width: 28cqi;
      height: 42cqi;
    }
  }

  @media (max-width: 768px) {
    .lightbox-close,
    .lightbox-nav {
      width: 44px;
      height: 44px;
    }

    .lightbox-prev {
      left: 10px;
    }

    .lightbox-next {
      right: 10px;
    }

    .lightbox-close {
      top: 10px;
      right: 10px;
    }
  }
</style>
